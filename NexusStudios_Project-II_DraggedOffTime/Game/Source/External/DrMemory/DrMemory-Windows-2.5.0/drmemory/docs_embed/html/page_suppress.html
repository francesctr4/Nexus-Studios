---
title: "Suppressing Errors"
layout: default
permalink: /page_suppress.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Suppressing Errors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If Dr. Memory is reporting numerous errors that appear to be false positives and originate in libraries that are not part of your application, consider using the blocklist and allowlist options to isolate them, which may be more effective than suppressing individual errors. See <a class="el" href="page_running.html#sec_potential_errors">Application Versus System Library Errors</a> for more information.</p>
<p>To aid in suppressing individual errors, Dr. Memory generates a file named <code>suppress.txt</code> alongside the <code>results.txt</code> file. To suppress errors from being reported in future runs, edit this file to contain just the errors you wish to suppress. Then pass the file to <code>drmemory</code> with the -suppress option:</p>
<pre class="fragment">drmemory.exe -suppress c:/suppress-custom.txt -- myapp
</pre><p>The suppress.txt generated by Dr. Memory will contain suppression information only for those errors that weren't suppressed using the -suppress option. For each error reported in suppress.txt, there will be two types of call stacks, one showing <code>&lt;module+offset&gt;</code> type frames and the other <code>module!function</code> type frames. The offset in <code>&lt;module+offset&gt;</code> must be a lower-case hexadecimal constant (e.g., <code>0x4af</code>) and is the offset from the start of the module. Either type of call stack can be used and it is enough if one of those two is specified. The <code>module!function</code> are more general and more robust across different versions of a module.</p>
<p>In order to simplify writing suppressions, callstacks support "*" and "?" wildcards in either the module or function name (or offset for <code>&lt;module+offset&gt;</code>). A "*" matches any number of characters of any kind. A "?" matches a single character of any kind. C++ functions should be in their unmangled form. If a literal "*" is desired, a "?" should usually be used instead to avoid the "*" wildcard expansion.</p>
<p>To match any frame at all, use a single "*". To match any module but not any non-module (and thus not match a system call or non-module code, such as generated code), use "*!*".</p>
<p>Callstacks automatically employ prefix matching. Prefix matching means that the callstack in the suppression file is considered a match if it matches the top of any actual callstack during a run. This allows specifying only the first few frames of a callstack and have it match any callstack whose first frames match those frames, regardless of subsequent frames.</p>
<p>A final type of wildcard frame is supported: "...". A callstack frame consisting of the string "..." matches zero or more frames in the callstack.</p>
<p>As a variation on the "..." ellipsis frame, "module!..." matches one or more frames in a given module. Importantly, it will not match zero frames like a plain ellipsis. This form is most useful for suppressing reports through system libraries that are missing symbols, because oftentimes such reports can be identified by the way they call back and forth across system library boundaries.</p>
<p>Suppression files can have empty lines and comment lines (begining with #). There should be no leading white space for the actual suppression information. Suppressions should not end with "...", which is unnecessary due to the implicit prefix matching.</p>
<p>A suppression can be given an identifier with a <code>name=</code> line after the error type line. Suppressions that were matched are printed in the results file with a count of how many unique callstacks were matched. Duplicate callstacks are not included. Here is an example:</p>
<div class="fragment"><div class="line">LEAK</div>
<div class="line">name=bug #456 (deliberately leaked object)</div>
<div class="line">mylib.dll!LeakMe</div>
<div class="line">mylib.dll!*</div>
</div><!-- fragment --><p>On Windows, for unaddressable accesses and uninitialized reads, a suppression can be further restricted by the actual instruction involved. The instruction is printed out in an error report in a <code>Note:</code> field. For example: </p><div class="fragment"><div class="line">Error #8: UNADDRESSABLE ACCESS beyond heap bounds: reading 0x001338a8-0x001338ac 4 byte(s)</div>
<div class="line">...</div>
<div class="line">Note: instruction: mov    (%eax) -&gt; %eax</div>
</div><!-- fragment --><p>A suppression can contain an <code>instruction=</code> line after the error type line which will be matched against this note field. It can contain wildcards. Here is an example:</p>
<div class="fragment"><div class="line">UNINITIALIZED READ</div>
<div class="line">name=bug #123 (deliberate uninitialized read to generate random number)</div>
<div class="line">instruction=test   * $0x00000?00</div>
<div class="line">myranlib.dll!GenRanHelper*</div>
<div class="line">myranlib.dll!GenRan*</div>
</div><!-- fragment --><p>For users with existing Valgrind Memcheck suppression files, Dr. Memory supports Valgrind-style suppressions, but not with mangled C++ symbols. On Linux and Mac, a script called <code>valgrind2drmemory.pl</code> is provided in the bin directory that can be used to convert a legacy Valgrind suppression file to the Dr. Memory format. It uses heuristics to convert mangled C++ symbols that contain wildcards and may not succeed on complex types (it prints a warning for those it fails on). Use it like this:</p>
<div class="fragment"><div class="line">bin/valgrind2drmemory.pl /path/to/old-supp-file /path/to/<span class="keyword">new</span>-drmem-towrite</div>
</div><!-- fragment --><p>The Dr. Memory suppression format is more powerful then the Valgrind format and matches the Windows module!function standards used by other tools. We recommend converting to the Dr. Memory format from a legacy format.</p>
<p>Another method of ignoring errors is to filter the reported errors to focus on particular source files or particular libraries, using Dr. Memory's allowlisting options. See <a class="el" href="page_running.html#sec_potential_errors">Application Versus System Library Errors</a> for further information on allowlists.</p>
<p>A final method of ignoring uninitialized reads, in particular, for an entire library is described in <a class="el" href="page_running.html#sec_no_uninit_checks">Eliminating Uninitialized Read Checks By Library</a>.</p>
<p>To get more information on what errors are being suppressed, run with <code>-log_suppressed_errors</code>. All suppressed reports will be printed to the global logfile.</p>
<p>Dr. Memory comes with a set of default suppressions to avoid certain known false positives (and known true positives, i.e., actual bugs) in the C and C++ libraries and other locations. These can be disabled with the option -no_default_suppress. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.19-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 2.5.0 --- Mon Oct 18 2021 03:09:18 &nbsp; <img border=0 src="favicon.png">
</small></address>
